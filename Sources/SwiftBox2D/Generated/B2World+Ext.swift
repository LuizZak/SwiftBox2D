// HEADS UP!: Auto-generated file, changes made directly here will be overwritten by code generators.
// Generated by generate_types.py

import box2d

public extension B2World {
    /// World id validation. Provides validation for up to 64K allocations.
    func isValid() -> Bool {
        b2World_IsValid(id)
    }
    
    /// Simulate a world for one time step. This performs collision detection, integration, and constraint solution.
    /// - param worldId: The world to simulate
    /// - param timeStep: The amount of time to simulate, this should be a fixed number. Usually 1/60.
    /// - param subStepCount: The number of sub-steps, increasing the sub-step count can increase accuracy. Usually 4.
    func step(_ timeStep: Float, _ subStepCount: Int32) {
        b2World_Step(id, timeStep, subStepCount)
    }
    
    /// Call this to draw shapes and other debug draw data
    func draw(_ draw: UnsafeMutablePointer<b2DebugDraw>?) {
        b2World_Draw(id, draw)
    }
    
    /// Get the body events for the current time step. The event data is transient. Do not store a reference to this data.
    func getBodyEvents() -> b2BodyEvents {
        b2World_GetBodyEvents(id)
    }
    
    /// Get sensor events for the current time step. The event data is transient. Do not store a reference to this data.
    func getSensorEvents() -> b2SensorEvents {
        b2World_GetSensorEvents(id)
    }
    
    /// Get contact events for this current time step. The event data is transient. Do not store a reference to this data.
    func getContactEvents() -> b2ContactEvents {
        b2World_GetContactEvents(id)
    }
    
    /// Overlap test for all shapes that *potentially* overlap the provided AABB
    func overlapAABB(_ aabb: B2AABB, _ filter: B2QueryFilter, _ fcn: @convention(c) (b2ShapeId, UnsafeMutableRawPointer?) -> Bool, _ context: UnsafeMutableRawPointer?) -> b2TreeStats {
        b2World_OverlapAABB(id, aabb, filter, fcn, context)
    }
    
    /// Overlap test for all shapes that overlap the provided shape proxy.
    func overlapShape(_ proxy: UnsafeMutablePointer<b2ShapeProxy>?, _ filter: B2QueryFilter, _ fcn: @convention(c) (b2ShapeId, UnsafeMutableRawPointer?) -> Bool, _ context: UnsafeMutableRawPointer?) -> b2TreeStats {
        b2World_OverlapShape(id, proxy, filter, fcn, context)
    }
    
    /// Cast a ray into the world to collect shapes in the path of the ray.
    /// Your callback function controls whether you get the closest point, any point, or n-points.
    /// The ray-cast ignores shapes that contain the starting point.
    /// - note: The callback function may receive shapes in any order
    /// - param worldId: The world to cast the ray against
    /// - param origin: The start point of the ray
    /// - param translation: The translation of the ray from the start point to the end point
    /// - param filter: Contains bit flags to filter unwanted shapes from the results
    /// - param fcn: A user implemented callback function
    /// - param context: A user context that is passed along to the callback function
    /// - returns: traversal performance counters
    func castRay(_ origin: B2Vec2, _ translation: B2Vec2, _ filter: B2QueryFilter, _ fcn: @convention(c) (b2ShapeId, b2Vec2, b2Vec2, Float, UnsafeMutableRawPointer?) -> Float, _ context: UnsafeMutableRawPointer?) -> b2TreeStats {
        b2World_CastRay(id, origin, translation, filter, fcn, context)
    }
    
    /// Cast a ray into the world to collect the closest hit. This is a convenience function.
    /// This is less general than b2World_CastRay() and does not allow for custom filtering.
    func castRayClosest(_ origin: B2Vec2, _ translation: B2Vec2, _ filter: B2QueryFilter) -> b2RayResult {
        b2World_CastRayClosest(id, origin, translation, filter)
    }
    
    /// Cast a shape through the world. Similar to a cast ray except that a shape is cast instead of a point.
    /// @see b2World_CastRay
    func castShape(_ proxy: UnsafeMutablePointer<b2ShapeProxy>?, _ translation: B2Vec2, _ filter: B2QueryFilter, _ fcn: @convention(c) (b2ShapeId, b2Vec2, b2Vec2, Float, UnsafeMutableRawPointer?) -> Float, _ context: UnsafeMutableRawPointer?) -> b2TreeStats {
        b2World_CastShape(id, proxy, translation, filter, fcn, context)
    }
    
    /// Cast a capsule mover through the world. This is a special shape cast that handles sliding along other shapes while reducing
    /// clipping.
    func castMover(_ mover: UnsafeMutablePointer<b2Capsule>?, _ translation: B2Vec2, _ filter: B2QueryFilter) -> Float {
        b2World_CastMover(id, mover, translation, filter)
    }
    
    /// Collide a capsule mover with the world, gathering collision planes that can be fed to b2SolvePlanes. Useful for
    /// kinematic character movement.
    func collideMover(_ mover: UnsafeMutablePointer<b2Capsule>?, _ filter: B2QueryFilter, _ fcn: @convention(c) (b2ShapeId, UnsafePointer<b2PlaneResult>?, UnsafeMutableRawPointer?) -> Bool, _ context: UnsafeMutableRawPointer?) {
        b2World_CollideMover(id, mover, filter, fcn, context)
    }
    
    /// Enable/disable sleep. If your application does not need sleeping, you can gain some performance
    /// by disabling sleep completely at the world level.
    /// @see b2WorldDef
    func enableSleeping(_ flag: Bool) {
        b2World_EnableSleeping(id, flag)
    }
    
    /// Is body sleeping enabled?
    func isSleepingEnabled() -> Bool {
        b2World_IsSleepingEnabled(id)
    }
    
    /// Enable/disable continuous collision between dynamic and static bodies. Generally you should keep continuous
    /// collision enabled to prevent fast moving objects from going through static objects. The performance gain from
    /// disabling continuous collision is minor.
    /// @see b2WorldDef
    func enableContinuous(_ flag: Bool) {
        b2World_EnableContinuous(id, flag)
    }
    
    /// Is continuous collision enabled?
    func isContinuousEnabled() -> Bool {
        b2World_IsContinuousEnabled(id)
    }
    
    /// Register the custom filter callback. This is optional.
    func setCustomFilterCallback(_ fcn: @convention(c) (b2ShapeId, b2ShapeId, UnsafeMutableRawPointer?) -> Bool, _ context: UnsafeMutableRawPointer?) {
        b2World_SetCustomFilterCallback(id, fcn, context)
    }
    
    /// Register the pre-solve callback. This is optional.
    func setPreSolveCallback(_ fcn: @convention(c) (b2ShapeId, b2ShapeId, UnsafeMutablePointer<b2Manifold>?, UnsafeMutableRawPointer?) -> Bool, _ context: UnsafeMutableRawPointer?) {
        b2World_SetPreSolveCallback(id, fcn, context)
    }
    
    /// Apply a radial explosion
    /// - param worldId: The world id
    /// - param explosionDef: The explosion definition
    func explode(_ explosionDef: UnsafeMutablePointer<b2ExplosionDef>?) {
        b2World_Explode(id, explosionDef)
    }
    
    /// Adjust contact tuning parameters
    /// - param worldId: The world id
    /// - param hertz: The contact stiffness (cycles per second)
    /// - param dampingRatio: The contact bounciness with 1 being critical damping (non-dimensional)
    /// - param pushSpeed: The maximum contact constraint push out speed (meters per second)
    /// - note: Advanced feature
    func setContactTuning(_ hertz: Float, _ dampingRatio: Float, _ pushSpeed: Float) {
        b2World_SetContactTuning(id, hertz, dampingRatio, pushSpeed)
    }
    
    /// Adjust joint tuning parameters
    /// - param worldId: The world id
    /// - param hertz: The contact stiffness (cycles per second)
    /// - param dampingRatio: The contact bounciness with 1 being critical damping (non-dimensional)
    /// - note: Advanced feature
    func setJointTuning(_ hertz: Float, _ dampingRatio: Float) {
        b2World_SetJointTuning(id, hertz, dampingRatio)
    }
    
    /// Enable/disable constraint warm starting. Advanced feature for testing. Disabling
    /// warm starting greatly reduces stability and provides no performance gain.
    func enableWarmStarting(_ flag: Bool) {
        b2World_EnableWarmStarting(id, flag)
    }
    
    /// Is constraint warm starting enabled?
    func isWarmStartingEnabled() -> Bool {
        b2World_IsWarmStartingEnabled(id)
    }
    
    /// Get the number of awake bodies.
    func getAwakeBodyCount() -> Int32 {
        b2World_GetAwakeBodyCount(id)
    }
    
    /// Get the current world performance profile
    func getProfile() -> b2Profile {
        b2World_GetProfile(id)
    }
    
    /// Get world counters and sizes
    func getCounters() -> b2Counters {
        b2World_GetCounters(id)
    }
    
    /// Set the user data pointer.
    func setUserData(_ userData: UnsafeMutableRawPointer?) {
        b2World_SetUserData(id, userData)
    }
    
    /// Set the friction callback. Passing NULL resets to default.
    func setFrictionCallback(_ callback: @convention(c) (Float, Int32, Float, Int32) -> Float) {
        b2World_SetFrictionCallback(id, callback)
    }
    
    /// Set the restitution callback. Passing NULL resets to default.
    func setRestitutionCallback(_ callback: @convention(c) (Float, Int32, Float, Int32) -> Float) {
        b2World_SetRestitutionCallback(id, callback)
    }
    
    /// Dump memory stats to box2d_memory.txt
    func dumpMemoryStats() {
        b2World_DumpMemoryStats(id)
    }
    
    /// This is for internal testing
    func rebuildStaticTree() {
        b2World_RebuildStaticTree(id)
    }
    
    /// This is for internal testing
    func enableSpeculative(_ flag: Bool) {
        b2World_EnableSpeculative(id, flag)
    }
    
    ///  Get the the restitution speed threshold. Usually in meters per second.
    /// Adjust the restitution threshold. It is recommended not to make this value very small
    /// because it will prevent bodies from sleeping. Usually in meters per second.
    /// @see b2WorldDef
    var restitutionThreshold: Float {
        get {
            b2World_GetRestitutionThreshold(id)
        }
        set(value) {
            b2World_SetRestitutionThreshold(id, value)
        }
    }
    
    ///  Get the the hit event speed threshold. Usually in meters per second.
    /// Adjust the hit event threshold. This controls the collision speed needed to generate a b2ContactHitEvent.
    /// Usually in meters per second.
    /// @see b2WorldDef::hitEventThreshold
    var hitEventThreshold: Float {
        get {
            b2World_GetHitEventThreshold(id)
        }
        set(value) {
            b2World_SetHitEventThreshold(id, value)
        }
    }
    
    ///  Get the gravity vector
    /// Set the gravity vector for the entire world. Box2D has no concept of an up direction and this
    /// is left as a decision for the application. Usually in m/s^2.
    /// @see b2WorldDef
    var gravity: B2Vec2 {
        get {
            b2World_GetGravity(id)
        }
        set(gravity) {
            b2World_SetGravity(id, gravity)
        }
    }
    
    /// Get the maximum linear speed. Usually in m/s.
    /// Set the maximum linear speed. Usually in m/s.
    var maximumLinearSpeed: Float {
        get {
            b2World_GetMaximumLinearSpeed(id)
        }
        set(maximumLinearSpeed) {
            b2World_SetMaximumLinearSpeed(id, maximumLinearSpeed)
        }
    }
}
