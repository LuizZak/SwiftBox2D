// HEADS UP!: Auto-generated file, changes made directly here will be overwritten by code generators.
// Generated by generate_types.py

import box2d

public extension B2World {
    /// World id validation. Provides validation for up to 64K allocations.
    func isValid() -> Bool {
        b2World_IsValid(id)
    }
    
    /// Simulate a world for one time step. This performs collision detection, integration, and constraint solution.
    /// - param worldId: The world to simulate
    /// - param timeStep: The amount of time to simulate, this should be a fixed number. Typically 1/60.
    /// - param subStepCount: The number of sub-steps, increasing the sub-step count can increase accuracy. Typically 4.
    func step(_ timeStep: Float, _ subStepCount: Int32) {
        b2World_Step(id, timeStep, subStepCount)
    }
    
    /// Call this to draw shapes and other debug draw data
    func draw(_ draw: UnsafeMutablePointer<b2DebugDraw>?) {
        b2World_Draw(id, draw)
    }
    
    /// Get the body events for the current time step. The event data is transient. Do not store a reference to this data.
    func getBodyEvents() -> b2BodyEvents {
        b2World_GetBodyEvents(id)
    }
    
    /// Get sensor events for the current time step. The event data is transient. Do not store a reference to this data.
    func getSensorEvents() -> b2SensorEvents {
        b2World_GetSensorEvents(id)
    }
    
    /// Get contact events for this current time step. The event data is transient. Do not store a reference to this data.
    func getContactEvents() -> b2ContactEvents {
        b2World_GetContactEvents(id)
    }
    
    /// Overlap test for all shapes that *potentially* overlap the provided AABB
    func overlapAABB(_ aabb: B2AABB, _ filter: B2QueryFilter, _ fcn: @convention(c) (b2ShapeId, UnsafeMutableRawPointer?) -> Bool, _ context: UnsafeMutableRawPointer?) -> b2TreeStats {
        b2World_OverlapAABB(id, aabb, filter, fcn, context)
    }
    
    /// Overlap test for for all shapes that overlap the provided point.
    func overlapPoint(_ point: B2Vec2, _ transform: B2Transform, _ filter: B2QueryFilter, _ fcn: @convention(c) (b2ShapeId, UnsafeMutableRawPointer?) -> Bool, _ context: UnsafeMutableRawPointer?) -> b2TreeStats {
        b2World_OverlapPoint(id, point, transform, filter, fcn, context)
    }
    
    /// Overlap test for for all shapes that overlap the provided circle. A zero radius may be used for a point query.
    func overlapCircle(_ circle: UnsafeMutablePointer<b2Circle>?, _ transform: B2Transform, _ filter: B2QueryFilter, _ fcn: @convention(c) (b2ShapeId, UnsafeMutableRawPointer?) -> Bool, _ context: UnsafeMutableRawPointer?) -> b2TreeStats {
        b2World_OverlapCircle(id, circle, transform, filter, fcn, context)
    }
    
    /// Overlap test for all shapes that overlap the provided capsule
    func overlapCapsule(_ capsule: UnsafeMutablePointer<b2Capsule>?, _ transform: B2Transform, _ filter: B2QueryFilter, _ fcn: @convention(c) (b2ShapeId, UnsafeMutableRawPointer?) -> Bool, _ context: UnsafeMutableRawPointer?) -> b2TreeStats {
        b2World_OverlapCapsule(id, capsule, transform, filter, fcn, context)
    }
    
    /// Overlap test for all shapes that overlap the provided polygon
    func overlapPolygon(_ polygon: UnsafeMutablePointer<b2Polygon>?, _ transform: B2Transform, _ filter: B2QueryFilter, _ fcn: @convention(c) (b2ShapeId, UnsafeMutableRawPointer?) -> Bool, _ context: UnsafeMutableRawPointer?) -> b2TreeStats {
        b2World_OverlapPolygon(id, polygon, transform, filter, fcn, context)
    }
    
    /// Cast a ray into the world to collect shapes in the path of the ray.
    /// Your callback function controls whether you get the closest point, any point, or n-points.
    /// The ray-cast ignores shapes that contain the starting point.
    /// - note: The callback function may receive shapes in any order
    /// - param worldId: The world to cast the ray against
    /// - param origin: The start point of the ray
    /// - param translation: The translation of the ray from the start point to the end point
    /// - param filter: Contains bit flags to filter unwanted shapes from the results
    /// - param fcn: A user implemented callback function
    /// - param context: A user context that is passed along to the callback function
    /// - returns: traversal performance counters
    func castRay(_ origin: B2Vec2, _ translation: B2Vec2, _ filter: B2QueryFilter, _ fcn: @convention(c) (b2ShapeId, b2Vec2, b2Vec2, Float, UnsafeMutableRawPointer?) -> Float, _ context: UnsafeMutableRawPointer?) -> b2TreeStats {
        b2World_CastRay(id, origin, translation, filter, fcn, context)
    }
    
    /// Cast a ray into the world to collect the closest hit. This is a convenience function.
    /// This is less general than b2World_CastRay() and does not allow for custom filtering.
    func castRayClosest(_ origin: B2Vec2, _ translation: B2Vec2, _ filter: B2QueryFilter) -> b2RayResult {
        b2World_CastRayClosest(id, origin, translation, filter)
    }
    
    /// Cast a circle through the world. Similar to a cast ray except that a circle is cast instead of a point.
    /// @see b2World_CastRay
    func castCircle(_ circle: UnsafeMutablePointer<b2Circle>?, _ originTransform: B2Transform, _ translation: B2Vec2, _ filter: B2QueryFilter, _ fcn: @convention(c) (b2ShapeId, b2Vec2, b2Vec2, Float, UnsafeMutableRawPointer?) -> Float, _ context: UnsafeMutableRawPointer?) -> b2TreeStats {
        b2World_CastCircle(id, circle, originTransform, translation, filter, fcn, context)
    }
    
    /// Cast a capsule through the world. Similar to a cast ray except that a capsule is cast instead of a point.
    /// @see b2World_CastRay
    func castCapsule(_ capsule: UnsafeMutablePointer<b2Capsule>?, _ originTransform: B2Transform, _ translation: B2Vec2, _ filter: B2QueryFilter, _ fcn: @convention(c) (b2ShapeId, b2Vec2, b2Vec2, Float, UnsafeMutableRawPointer?) -> Float, _ context: UnsafeMutableRawPointer?) -> b2TreeStats {
        b2World_CastCapsule(id, capsule, originTransform, translation, filter, fcn, context)
    }
    
    /// Cast a polygon through the world. Similar to a cast ray except that a polygon is cast instead of a point.
    /// @see b2World_CastRay
    func castPolygon(_ polygon: UnsafeMutablePointer<b2Polygon>?, _ originTransform: B2Transform, _ translation: B2Vec2, _ filter: B2QueryFilter, _ fcn: @convention(c) (b2ShapeId, b2Vec2, b2Vec2, Float, UnsafeMutableRawPointer?) -> Float, _ context: UnsafeMutableRawPointer?) -> b2TreeStats {
        b2World_CastPolygon(id, polygon, originTransform, translation, filter, fcn, context)
    }
    
    /// Enable/disable sleep. If your application does not need sleeping, you can gain some performance
    /// by disabling sleep completely at the world level.
    /// @see b2WorldDef
    func enableSleeping(_ flag: Bool) {
        b2World_EnableSleeping(id, flag)
    }
    
    /// Is body sleeping enabled?
    func isSleepingEnabled() -> Bool {
        b2World_IsSleepingEnabled(id)
    }
    
    /// Enable/disable continuous collision between dynamic and static bodies. Generally you should keep continuous
    /// collision enabled to prevent fast moving objects from going through static objects. The performance gain from
    /// disabling continuous collision is minor.
    /// @see b2WorldDef
    func enableContinuous(_ flag: Bool) {
        b2World_EnableContinuous(id, flag)
    }
    
    /// Is continuous collision enabled?
    func isContinuousEnabled() -> Bool {
        b2World_IsContinuousEnabled(id)
    }
    
    /// Register the custom filter callback. This is optional.
    func setCustomFilterCallback(_ fcn: @convention(c) (b2ShapeId, b2ShapeId, UnsafeMutableRawPointer?) -> Bool, _ context: UnsafeMutableRawPointer?) {
        b2World_SetCustomFilterCallback(id, fcn, context)
    }
    
    /// Register the pre-solve callback. This is optional.
    func setPreSolveCallback(_ fcn: @convention(c) (b2ShapeId, b2ShapeId, UnsafeMutablePointer<b2Manifold>?, UnsafeMutableRawPointer?) -> Bool, _ context: UnsafeMutableRawPointer?) {
        b2World_SetPreSolveCallback(id, fcn, context)
    }
    
    /// Apply a radial explosion
    /// - param worldId: The world id
    /// - param explosionDef: The explosion definition
    func explode(_ explosionDef: UnsafeMutablePointer<b2ExplosionDef>?) {
        b2World_Explode(id, explosionDef)
    }
    
    /// Adjust contact tuning parameters
    /// - param worldId: The world id
    /// - param hertz: The contact stiffness (cycles per second)
    /// - param dampingRatio: The contact bounciness with 1 being critical damping (non-dimensional)
    /// - param pushVelocity: The maximum contact constraint push out velocity (meters per second)
    /// - note: Advanced feature
    func setContactTuning(_ hertz: Float, _ dampingRatio: Float, _ pushVelocity: Float) {
        b2World_SetContactTuning(id, hertz, dampingRatio, pushVelocity)
    }
    
    /// Adjust joint tuning parameters
    /// - param worldId: The world id
    /// - param hertz: The contact stiffness (cycles per second)
    /// - param dampingRatio: The contact bounciness with 1 being critical damping (non-dimensional)
    /// - note: Advanced feature
    func setJointTuning(_ hertz: Float, _ dampingRatio: Float) {
        b2World_SetJointTuning(id, hertz, dampingRatio)
    }
    
    /// Enable/disable constraint warm starting. Advanced feature for testing. Disabling
    /// sleeping greatly reduces stability and provides no performance gain.
    func enableWarmStarting(_ flag: Bool) {
        b2World_EnableWarmStarting(id, flag)
    }
    
    /// Is constraint warm starting enabled?
    func isWarmStartingEnabled() -> Bool {
        b2World_IsWarmStartingEnabled(id)
    }
    
    /// Get the current world performance profile
    func getProfile() -> b2Profile {
        b2World_GetProfile(id)
    }
    
    /// Get world counters and sizes
    func getCounters() -> b2Counters {
        b2World_GetCounters(id)
    }
    
    /// Set the user data pointer.
    func setUserData(_ userData: UnsafeMutableRawPointer?) {
        b2World_SetUserData(id, userData)
    }
    
    /// Dump memory stats to box2d_memory.txt
    func dumpMemoryStats() {
        b2World_DumpMemoryStats(id)
    }
    
    /// todo testing
    func rebuildStaticTree() {
        b2World_RebuildStaticTree(id)
    }
    
    ///  Get the the restitution speed threshold. Typically in meters per second.
    /// Adjust the restitution threshold. It is recommended not to make this value very small
    /// because it will prevent bodies from sleeping. Typically in meters per second.
    /// @see b2WorldDef
    var restitutionThreshold: Float {
        get {
            b2World_GetRestitutionThreshold(id)
        }
        set(value) {
            b2World_SetRestitutionThreshold(id, value)
        }
    }
    
    ///  Get the the hit event speed threshold. Typically in meters per second.
    /// Adjust the hit event threshold. This controls the collision velocity needed to generate a b2ContactHitEvent.
    /// Typically in meters per second.
    /// @see b2WorldDef::hitEventThreshold
    var hitEventThreshold: Float {
        get {
            b2World_GetHitEventThreshold(id)
        }
        set(value) {
            b2World_SetHitEventThreshold(id, value)
        }
    }
    
    ///  Get the gravity vector
    /// Set the gravity vector for the entire world. Box2D has no concept of an up direction and this
    /// is left as a decision for the application. Typically in m/s^2.
    /// @see b2WorldDef
    var gravity: B2Vec2 {
        get {
            b2World_GetGravity(id)
        }
        set(gravity) {
            b2World_SetGravity(id, gravity)
        }
    }
    
    /// Get the maximum linear velocity. Typically in m/s.
    /// Set the maximum linear velocity. Typically in m/s.
    var maximumLinearVelocity: Float {
        get {
            b2World_GetMaximumLinearVelocity(id)
        }
        set(maximumLinearVelocity) {
            b2World_SetMaximumLinearVelocity(id, maximumLinearVelocity)
        }
    }
}
